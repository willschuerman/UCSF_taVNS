<usermanual>
						
								SUSTAINED ATTENTION TO RESPONSE TASK (SART)
								   (with optional "Mindwandering Probes")
SCRIPT INFO

Script Author: Katja Borchert, Ph.D. (katjab@millisecond.com) for Millisecond Software, LLC
Date: 10-15-2013
last updated: 02-13-2017 by K.Borchert (katjab@millisecond.com) for Millisecond Software LLC

Copyright © 02-13-2017 Millisecond Software


BACKGROUND INFO

											*Purpose*
This script implements the Sustained Attention to Response Task (SART) as described in:

Robertson, I. H., Manly, T., Andrade, J., Baddeley, B. T., & Yiend, J. (1997). ‘Oops!’: Performance correlates of 
everyday attentional failures in traumatic brain injured and normal subjects. Neuropsychologia, 35(6), 747–758.

and 

Cheyne, J.A., Solman, G.J.F., Carriere, J.S.A., & Smilek, D. (2009). Anatomy of an error: A bidirectional state model of task
engagement/disengagement and attention-related errors. Cognition, 111, 98–113.

The SART is a type of Go/NoGo task in which the nogo stimulus is presented very infrequently.


!NOTE: This script includes an optional "Mindwandering Probe" addition for the SART.iqx.
The code is provided in helper script "SART_MindWanderingProbeAddition.iqx". More info about
the mindwandering probe in the additional script.
To run the probe addition, go to section Editable Parameters and set parameters.run_mindwanderingprobe = true (default is false)



											  *Task*
Participants are presented with a single digit 1-9 in the middle of the screen in varying fontsizes.
The digit disappears after a short while and is replaced with a mask (circle with an X).
Participants are asked to press the SPACEBAR if any digit other than 3 is presented and to withhold the response
if digit 3 presented.


DATA FILE INFORMATION: 
The default data stored in the data files are:

(1) Raw data file: 'SART.iqdat' (a separate file for each participant)

build:							Inquisit build
computer.platform:				the platform the script was run on
date, time, subject, group:		date and time script was run with the current subject/groupnumber 
blockcode, blocknum:			the name and number of the current block
trialcode, trialnum: 			the name and number of the currently recorded trial
									(Note: not all trials that are run might record data; by default data is collected unless /recorddata = false is set for a particular trial/block) 
/trialcount:					counts all test trials
/digitpresentationtime:			digit duration in ms (default: 250ms)
/maskpresentationtime:			mask duration in ms (default: 900ms)

/trialtype:						"Go" (digit !=3); "NoGo" (digit == 3)
/digit:							contains the currently selected digit
/fontsize:						contains the currently (randomly) selected fontsize
response:						the participant's response
										SART trials: 0 for no response or 57 for Spacebar
										Probe trials (if run): the selected anchor digit
correct:						the correctness of the response (1 = correct; 0 = error)
RT:								the latency of the response in ms (= trial latency unless no response was given; no response leaves values.RT empty)
latency: 						the trial latency in ms (if no response, trial latency shows the trialduration)
/latencytype:					0 = no response given (suppression); 1 = anticipatory latency (< parameters.anticipatoryresponsetime);
								2 = ambiguous latency; 3 = valid latency  (>= parameters.validresponsetime)
									Note: independent of Go-NoGo trialtype
/responsetype:					"NoGo Success": correctly suppressed response to NoGo trial (digit 3)
								"Omission": incorrectly suppressed response to a Go trial (digit other than 3)
								"NoGo Failure": any response to a NoGo trial
								"Go Anticipatory": anticipatory response for Go trials with latencies < parameters.anticipatoryresponsetime
								"Go Ambiguous": ambiguous response for Go trials
								"Go Success": valid response for Go trials with latencies >= parameters.validresponsetime
/count_anticipatory:			counts the number of times a Go-latency was faster than parameters.anticipatoryresponsetime
/correctsuppressions:			counts number of correct suppressions (-> no response to digit 3)
/incorrectsuppressions:			counts number of incorrect suppressions (-> no response to digit other than 3)
/count_NoGo:					counts NoGo trials (digit 3)
/count_Go:						counts Go trials (digits other than 3)
/count_validGo:					counts Go trials with a correct response and latencies >= parameters.validresponsetime
/countprobes:					counts the number of probes run

radiobuttons.difficulty.response:
radiobuttons.interest.response:			responses to the posttask survey questions

(2) Summary data file: 'summary.iqdat' (a separate file for each participant)

script.startdate:						date script was run
script.starttime:						time script was started
script.subjectid:						subject id number
script.groupid:							group id number
script.elapsedtime:						time it took to run script (in ms)
computer.platform:						the platform the script was run on
/completed:								0 = script was not completed (prematurely aborted); 1 = script was completed (all conditions run)
radiobuttons.difficulty.response:
radiobuttons.interest.response:			responses to the posttask survey questions (if run)

dropdown.age.response:					response to the age question at the end of the task
/ageGroup:								the assigned age group (1-6) based on age response. (used for reporting z-scores and percentiles)
											!Note: age groups correspond to the age cohorts used by Carriere et al (2010), table 2, p. 572

/nr_commissions:						absolute number of commission errors in NoGo trials (=NoGo failures; also reported as SART errors)				
/percent_commissions:					percentage of commission errors in NoGo trials (=NoGo failures; also reported as SART errors)
/z_commissions:							z-value of number of Commission errors based on Carriere et al (2010), table 2 (SART errors), p. 572
/percentile_commissions:				percentile of Commission z-value based on Carriere et al (2010), table 2 (SART errors), p. 572
/nr_omissions:							absolute number of omission errors in Go trials (=omission of response)
/percent_omissions:						percentage of incorrect suppressions in Go trials (=omission of response)
/z_omissions:							z-value of number Omission errors based on Carriere et al (2010), table 2, p. 572
/percentile_Omissions:					percentile of Omission z-value based on Carriere et al (2010), table 2, p. 572
/count_anticipatory:					counts the number of times a Go-latency was faster than parameters.anticipatoryresponsetime
/z_AnticipatoryResponses:				z-value of number Anticipatory Responses based on Carriere et al (2010), table 2, p. 572
/percentile_AnticipatoryResponses:		percentile of Anticipatory Responses z-value based on Carriere et al (2010), table 2, p. 572
/meanRT_go:								mean latency (in ms) of valid and correct Go trials (latencies >= parameters.validresponsetime)
/stdRT_go:								estimated standard deviation (STD) of valid and correct Go trials
/z_goRT:								z-value of mean go latency based on Carriere et al (2010), table 2, p. 572
/percentile_goRT:						percentile of goRT z-value based on Carriere et al (2010), table 2, p. 572
/CV_go:									coefficient of variablity (CV = STD/Mean) => a measure of variability independent of mean differences
/z_CV:									z-value of CV based on Carriere et al (2010), table 2, p. 572
/percentile_CV:							percentile of CV z-value based on Carriere et al (2010), table 2, p. 572

Mean RTs are calculated for the correct consecutive (not interrupted either by a NoGo or by an omission trial) last four Go- trials (digit other than 3) preceding successful NoGo trial
Mean RTs are calculated for the correct consecutive (not interrupted either by a NoGo or by an omission trial) last four Go- trials (digit other than 3)  preceding preceding failed NoGo trial
!!!!Note: in this script any 4 correct Go trials are counted irrespective of values.latencytype

/meanRT_GObeforesuccessNOGO:			mean latency (in ms) of consecutive 4 correct trials before correct suppression of response to digit 3
											(=> a measure of speed before successful NoGo trials)
/meanRT_GObeforefailedNOGO:				mean latency (in ms) of consecutive 4 correct trials before incorrect response of response to digit 3
											(=> a measure of speed before failed NoGo trials)
											
NORMS:
z-value and percentile calculations use data published by:

	Carriere, J.S.A., Cheyne, J.A., Solman, G.J.F. & Smilek, D. (2010). 
	Age Trends for Failures of Sustained Attention. Psychology and Aging, 25, 569–574.
	
Carriere et al (2010) grouped data by 6 age groups (no separate data for gender norms provided)	
Check helper script SART_Norms.iqx for more details.


EXPERIMENTAL SET-UP:
*9 digits, each of them presented 25 times = 225 trials
*in 5 fontsizes, each of them randomly selected 45 times (distribution across digits is randomly determined)
*in this script the digit order is semi-random, predetermined 
no special constraints were used to determine the order (only constraint: each digit is presented 25 times)
* List properties can be edited to change the order from a pre-fixed one to a random one. Further instructions under
(see section Editable Lists -> list.digitsequence for more information)

Trial Sequence:
digit (250ms) -> mask (900ms) -> <digit SOA: 1150ms> -> digit.....

=> Response latencies are measured from onset of digit and can therefore catch anticipatory responses 
	(latencies faster than parameters.anticipatoryresponsetime) (see discussion in Cheyne et al, 2009)

STIMULI
- digits 1-9 presented in fontstyle "Symbol" (if available on computer) 
- in 5 fontsizes
	=> fontsizes in this script are based on screen percentages and can be customized under 
	section Editable Lists -> list.fontsizes
- a picture mask (circle with an X) section Editable Stimuli -> picture.mask
- stimuli/mask presented in white on a black background

INSTRUCTIONS
Instructions are not original and can be customized under section Editable Instructions

EDITABLE CODE:
check below for (relatively) easily editable parameters, stimuli, instructions etc. 
Keep in mind that you can use this script as a template and therefore always "mess" with the entire code to further customize your experiment.

The parameters you can change are:

/digitpresentationtime:			digit duration in ms (default: 250ms)
/maskpresentationtime:			mask duration in ms (default: 900ms)
/ITI:							intertrial interval in ms (default: 0 => digit SOA is therefore 1150ms)
/responsekey:					the scancode of the response key (here: 57 -> Spacebar)
									Note: find scancodes under Tools -> Keyboard Scancodes	
/responsekey_label:				Label of response key (here: SPACEBAR)		
/maskheight:					the height/size of the mask (default: 20%)
									Note: Robertson et al (1997): mask size on their screen ~29mm
/anticipatoryresponsetime:		by default, latencies (in ms) are measured from digit onset
								latencies faster than anticipatoryresponsetime are interpreted as anticipatory
								as opposed to ambiguous/true responses to the digit (default: 100ms)
								(-> Cheyne et al, 2009)
/validresponsetime:				latencies (in ms) that are at or above validresponsetime are considered true 
								responses to the digits (default: 200ms)
								(-> Cheyne et al, 2009)

Minderwandering Probe Addition:
/run_mindwanderingprobe:		true: script runs the mindwandering probe addition
								false: script does not run the mindwandering probe addition  (default)
/postprobeduration:				intertrial pause between probe and re-start of SART (in ms)

</usermanual>


**************************************************************************************************************
**************************************************************************************************************
	EDITABLE PARAMETERS: change editable parameters here
**************************************************************************************************************
**************************************************************************************************************

<parameters>
/digitpresentationtime = 250
/maskpresentationtime = 900
/ITI = 0
/responsekey = 57
/responsekey_label = "SPACEBAR"
/maskheight = 20%
/anticipatoryresponsetime = 100
/validresponsetime = 200

/run_mindwanderingprobe = false
/postprobeduration = 500
</parameters>

**************************************************************************************************************
**************************************************************************************************************
	EDITABLE STIMULI: change editable stimuli here
**************************************************************************************************************
**************************************************************************************************************

Note: picture of the mask
<item mask>
/1 = "mask.png"
</item>


**************************************************************************************************************
**************************************************************************************************************
	EDITABLE INSTRUCTIONS: change instructions here
**************************************************************************************************************
**************************************************************************************************************
<instruct>
/fontstyle = ("Arial", 3.50%, false, false, false, false, 5, 1)
/txcolor = black
</instruct>

Note: These instructions are not original. Please customize.

<page intro>
In this task you will be presented with a single digit (1-9) in varying sizes in the middle of the screen
for a short duration. The digit is followed by a crossed circle.

^^Your task is to
^* press the <<%parameters.responsekey_label%>> when you see any digit other than 3
^* don't do anything (press no key) when you see digit 3. Just wait for the next digit.
^<%expressions.buttoninstruct1%>

^Use the index finger of your dominant hand when responding.

^^It's important to be accurate and fast in this study.

^^Press the SPACEBAR to continue to some practice trials.
</page>

<page practiceend>
Practice is over and the actual task is about to start. 

^^Remember:
^^Whenever there is a digit other than 3 (e.g. 1, 2, 4, 5, 6, 7, 8, 9), press the  <<%parameters.responsekey_label%>>
as fast as you can. However, if digit 3 is presented, don't do anything. Just wait for the next digit.

^^Use the index finger of your dominant hand when responding.

^^It's important to be accurate and fast in this study.

^^The task will take ~4 minutes.

^^Press the SPACEBAR to start.
</page>



*******************************
General Helper Instructions
******************************

<text getReady>
/items = ("Get Ready:
~n<%expressions.buttoninstruct2%>")
/ fontstyle = ("Arial", 5.00%, false, false, false, false, 5, 1)
/ size = (80%, 40%)
</text>

****************************************************************************************************
general instruction expressions: adjust the instruction text depending on device used to run script
****************************************************************************************************
<expressions>
/buttoninstruct1 = if (computer.touch && !computer.haskeyboard) {"The Spacebar response button will be located at the bottom of your screen.";} else {"";}
/buttoninstruct2 = if (computer.touch && !computer.haskeyboard) {"Place your index finger of your dominant hand over the <%parameters.responsekey_label%> button.";} else {"Place your index finger of your dominant hand on the <%parameters.responsekey_label%>.";}
</expressions>


**************************************************************************************************************
**************************************************************************************************************
	EDITABLE LISTS: change editable lists here
**************************************************************************************************************
**************************************************************************************************************

Note: 
* pre-fixed, semi-randomly assembled sequence of trialtypes/225 digits (9 digits * 25 repetitions)
=> Robertson et al (1997) distributed digit 3 in a prefixed semi-randomly fashion across the 225 trials
* to create a randomly selected sequence of digits that is created while running the experiment as
opposed to a pre-fixed one: replace /selectionmode = sequence with /replace = false


<list trialtype>
/items = (trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,
trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,
trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,
trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,
trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,
trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,
trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.nogo,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,
trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go,
trial.nogo,trial.go,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.nogo,trial.go,trial.go,trial.go,trial.go,trial.nogo,trial.go,trial.go,trial.go)
/selectionmode = sequence
/resetinterval = 1
</list>

<list digitsequence>
/items = (5,7,4,7,1,2,3,7,4,8,4,2,7,5,1,4,5,5,2,3,3,7,6,4,7,
2,1,7,3,1,1,4,2,2,9,8,5,5,1,8,2,2,4,1,1,8,3,4,3,4,
9,9,1,5,4,1,5,1,4,9,5,8,7,3,4,3,1,7,2,7,8,7,4,9,3,
8,8,4,6,1,4,2,7,9,9,8,3,5,1,8,5,2,8,6,5,4,6,4,5,1,
9,6,2,5,6,8,3,6,3,8,6,2,7,7,1,1,6,7,7,2,5,6,9,9,1,
5,2,3,3,9,4,4,4,9,6,2,5,6,6,9,5,7,4,9,4,6,8,6,8,8,
2,6,2,1,3,4,9,1,8,5,9,8,3,7,2,5,3,7,7,8,8,9,8,2,8,
4,2,5,5,3,5,6,4,6,6,7,9,3,8,3,9,6,3,2,6,3,1,7,6,6)
/selectionmode = list.trialtype.currentindex
/resetinterval = 1
</list>

Note: list of practice trialtypes
<list practice_trialtype>
/items = (
trial.practice_go, trial.practice_go, trial.practice_nogo, trial.practice_go, trial.practice_go, trial.practice_go, trial.practice_go, trial.practice_go, trial.practice_go,
trial.practice_go, trial.practice_go, trial.practice_nogo, trial.practice_go, trial.practice_go, trial.practice_go, trial.practice_go, trial.practice_go, trial.practice_go)
/replace = false
</list>

Note: list of digits used for practice; tied to list.practice_trialtypes
<list practice_digitsequence>
/items = (
1, 2, 3, 4, 5, 6, 7, 8, 9,
1, 2, 3, 4, 5, 6, 7, 8, 9)
/selectionmode = list.practice_trialtype.currentindex
</list>

Note: 
*list of random fontsizes in % of canvas height. Customize % to fit your screen.
=> Robertson et al (1997): sizes on their screen ranged from 12mm-29mm
* Fontsizes are randomly selected without replacement => same frequency
across all 225 trials

<list fontsizes>
/items = (10%, 13%, 16%, 19%, 21%)
/poolsize = 225
/replace = false
/ resetinterval = 1
</list>

<list practice_fontsizes>
/items = (10%, 13%, 16%, 19%, 21%)
/replace = true
</list>

**************************************************************************************************************
								!!!REMAINING CODE: Customize after careful consideration only!!!
**************************************************************************************************************


**************************************************************************************************************
**************************************************************************************************************
	DEFAULTS
**************************************************************************************************************
**************************************************************************************************************
script requires Inquisit 5.0.5.0 or higher

<defaults>
/minimumversion = "5.0.5.0"
/ fontstyle = ("Arial", 3%, false, false, false, false, 5, 1)
/txbgcolor = white
/ txcolor = (0, 0, 0)
/screencolor = white
</defaults>

**************************************************************************************************************
**************************************************************************************************************
	INCLUDE
**************************************************************************************************************
**************************************************************************************************************

<include>
/ file = "SART_MindWanderingProbeAddition.iqx"
/ file = "SART_Norms.iqx"
</include>

**************************************************************************************************************
**************************************************************************************************************
	DATA
**************************************************************************************************************
**************************************************************************************************************

Note: data file explanations under User Manual Information at the top

********************
raw data
********************

<data>
/columns = (build, computer.platform, date, time, subject, group, blockcode, blocknum, trialcode, trialnum, expressions.trialcount,
parameters.digitpresentationtime, parameters.maskpresentationtime, values.trialtype, values.digit, values.fontsize, 
response, correct, values.RT, latency, values.latencytype, values.responsetype, values.count_anticipatory,
values.correctsuppressions, values.count_NoGo, values.incorrectsuppressions, values.count_Go, values.count_validgo, values.countprobes,
radiobuttons.difficulty.response, radiobuttons.interest.response)
/separatefiles = true
</data>

********************
summary data
********************

<summarydata>
/columns = (script.startdate, script.starttime, script.subjectid, script.groupid, script.elapsedtime, computer.platform, values.completed,
radiobuttons.difficulty.response, radiobuttons.interest.response, dropdown.age.response, values.ageGroup,
expressions.nr_commissions, expressions.percent_commissions, values.z_commission, values.percentile_commission,
expressions.nr_omissions, expressions.percent_omissions, values.z_Omission, values.percentile_Omission,
values.count_anticipatory,  values.z_AnticipatoryResponses, values.percentile_AnticipatoryResponses,
expressions.meanRT_go, expressions.stdRT_go, values.z_goRT, values.percentile_goRT,
expressions.CV_go,  values.z_CV, values.percentile_CV,
expressions.meanRT_GObeforesuccessNOGO, expressions.meanRT_GObeforefailedNOGO,
)
/ separatefiles = true
</summarydata>

**************************************************************************************************************
**************************************************************************************************************
	VALUES: automatically updated
**************************************************************************************************************
**************************************************************************************************************
                                    
/completed:							0 = script was not completed (prematurely aborted); 1 = script was completed (all conditions run)

/probetrial:						stores whether the current SART trial is followed by a probe (1) or not (0) (if parameters.run_mindwanderingprobe = true)
/trialtype:							"Go" (digit !=3); "NoGo" (digit == 3)
/digit:								contains the currently selected digit
/fontsize:							contains the currently (randomly) selected fontsize
/correctsuppressions:				counts number of correct suppressions (-> no response to digit 3)
/incorrectsuppressions:				counts number of incorrect suppressions or omission of response (-> no response to digit other than 3)
/count_NoGo:						counts NoGo trials (digit 3)
/count_Go:							counts Go trials (digits other than 3)
/count_validGo:						counts correct Go trials with valid latencies
/RT:								saves the response latency (in ms) unless response is suppressed. In that case values.RT = ""
/latencytype:						0 = no response given (suppression); 1 = anticipatory latency (< parameters.anticipatoryresponsetime);
									2 = ambiguous latency; 3 = valid latency (>= parameters.validresponsetime)
									Note: independent of Go-NoGo trial
/responsetype:						"NoGo Success": correctly suppressed response to NoGo trial (digit 3)
									"Omission": incorrectly suppressed response to a Go trial (digit other than 3)
									"NoGo Failure": any response to a NoGo trial
									"Go Anticipatory": anticipatory response for Go trials with latencies < parameters.anticipatoryresponsetime
									"Go Ambiguous": ambiguous response for Go trials
									"Go Success": valid response for Go trials with latencies >= parameters.validresponsetime
/count_anticipatory:				counts the number of times a G0-latency was faster than parameters.anticipatoryresponsetime
/sumRT_GO:							sums up the valid latencies (in ms) of correct responses (latencies >= parameters.validresponsetime)
/ssdiffRT_go:						sums up the squared differences between valid latencies of correct responses latencies and mean latency
/RT1-
/RT4:								store the last four consecutive latencies of correctly responded nondigit3 trials (irrespective of values.latencytype)

/fourfilled:						1 = 4 consecutive latencies of correctly responded nondigit3 trials are available 
									0 = fewer than 4 consecutive latencies of correctly responded nondigit3 trials are available

/count_4RTs_successsuppression:		counts how often 4 consecutive latencies of correctly responded nondigit3 trials are available before a 
									successfully suppressed digit3 trial
/count_4RTs_failedsuppression:		counts how often 4 consecutive latencies of correctly responded nondigit3 trials are available before a 
									failed suppressed digit3 trial
/sumRT_successsuppression:			sums up all the latencies of 4 consecutive latencies of correctly responded nondigit3 trials before a 
									successfully suppressed digit3 trial
/sumRT_failedsuppression:			sums up all the latencies of 4 consecutive latencies of correctly responded nondigit3 trials before a 
									failed suppressed digit3 trial

/countprobes:						counts the number of probes run

<values>
/completed = 0
/probetrial = 0
/trialtype = 0
/digit = 0
/fontsize = 0
/correctsuppressions = 0
/incorrectsuppressions = 0
/count_NoGo = 0
/count_Go = 0
/count_validGo = 0
/RT = 0
/latencytype = ""
/responsetype = 0
/count_anticipatory = 0
/fourfilled = 0
/RT1 = 0
/RT2 = 0
/RT3 = 0
/RT4 = 0
/count_4RTs_successsuppression = 0
/count_4RTs_failedsuppression = 0
/sumRT_successsuppression = 0
/sumRT_failedsuppression = 0
/countprobes = 0
</values>

*******************************************************************************************************************
*******************************************************************************************************************
	EXPRESSIONS
*******************************************************************************************************************
*******************************************************************************************************************
/percent_NoGosuccess:					percentage of correct suppressions in NoGo trials (=No go success)
/percent_commissions:					percentage of commission errors in NoGo trials (=NoGo failures; also reported as SART errors)
/nr_commissions:						absolute number of commissions
/percent_omissions:						percentage of incorrect suppressions in Go trials (=omission of response)
/nr_omissions:							absolute number of omissions

Mean RTs are calculated for the correct consecutive (not interrupted either by a NoGo or by an omission trial) last four Go- trials (digit other than 3) preceding successful NoGo trial
Mean RTs are calculated for the correct consecutive (not interrupted either by a NoGo or by an omission trial) last four Go- trials (digit other than 3) preceding preceding failed NoGo trial
Note: in this script any 4 correct Go trials (=> Go trials that are responded to) are counted irrespective of values.latencytype

/meanRT_GObeforesuccessNOGO:				mean latency of consecutive 4 correct trials before correct suppression of response to digit 3
											(=> a measure of speed before successful NoGo trials)
/meanRT_GObeforefailedNOGO:					mean latency of consecutive 4 correct trials before incorrect response of response to digit 3
											(=> a measure of speed before failed NoGo trials)

/meanRT_go:									mean latency (in ms) of valid and correct Go trials (latencies >= parameters.validresponsetime)
/stdRT_go:									estimated standard deviation (STD) of valid and correct Go trial latencies
/CV_go:										coefficient of variablity (CV = STD/Mean) => a measure of variability independent of mean differences

<expressions>
/percent_NoGosuccess = (values.correctsuppressions/values.count_NoGo) * 100
/percent_commissions = 100 - expressions.percent_NoGosuccess
/nr_commissions = values.count_NoGo - values.correctsuppressions
/percent_omissions = (values.incorrectsuppressions/values.count_Go) * 100
/nr_omissions = values.incorrectsuppressions

/meanRT_GObeforesuccessNOGO = values.sumrt_successsuppression/(4* values.count_4rts_successsuppression)
/meanRT_GObeforefailedNOGO = values.sumrt_failedsuppression/(4*values.count_4rts_failedsuppression)

/meanRT_go = list.validGolatencies.mean
/stdRT_go = list.validGolatencies.standarddeviation
/CV_go = expressions.stdRT_go/expressions.meanRT_go

/trialcount = values.count_go + values.count_nogo
</expressions>

*******************************************************************************************************************
*******************************************************************************************************************
	STIMULI
*******************************************************************************************************************
*******************************************************************************************************************

<text digit>
/items = ("<%values.digit%>")
/ fontstyle = ("Symbol", values.fontsize, false, false, false, false, 5, 1)
/ txcolor = white
/txbgcolor = black
/position = (50%, 50%)
/erase = false
</text>

<picture mask>
/items = mask
/select = 1
/position = (50%, 50%)
/size = (100%, parameters.maskheight)
/erase = false
</picture>

Note: shape background is used to present the black background and erase the mask and achieve a steady SOA between digits
(Note: a black background element was used rather than setting the default background 'black' in order to  
to present radiobuttons during the (optional) mindwandering task. Radiobuttons do not show up on a default black background
in Inquisit 4.0.7)
<shape background>
/shape = rectangle
/position = (50%, 50%)
/size = (100%, 100%)
/color = black
/erase = false
</shape>

<text errorfeedback>
/items = ("Incorrect")
/txcolor = red
/txbgcolor = black
/position = (50%, 70%)
/ fontstyle = ("Arial", 5%, false, false, false, false, 5, 1)
/erase = false
</text>

*******************************************************************************************************************
*******************************************************************************************************************
	LISTS
*******************************************************************************************************************
*******************************************************************************************************************

Note: list created on runtime; it saves all valid latencies of correct Go trials
in order to calculate Std of correct and valid Go-latencies
<list validGolatencies>
</list>

*******************************************************************************************************************
*******************************************************************************************************************
	PRACTICE TRIALS
*******************************************************************************************************************
*******************************************************************************************************************

<trial practice_go>
/pretrialpause = parameters.ITI
/ontrialbegin = [
	values.trialtype =  "Go";
	values.digit = list.practice_digitsequence.nextvalue;
	values.fontsize = list.practice_fontsizes.nextvalue;
	trial.practice_go.insertstimulustime(picture.mask, parameters.digitpresentationtime);
	trial.practice_go.insertstimulustime(shape.background, (parameters.digitpresentationtime + parameters.maskpresentationtime));
]
/ ontrialend = [
		trial.practice_go.resetstimulusframes();
]
/stimulustimes = [0 = background, digit]
/beginresponsetime = 0
/responseinterrupt = frames
/ validresponse = (parameters.responsekey, 0)
/monkeyresponse = (parameters.responsekey)
/correctresponse = (parameters.responsekey)
/trialduration = parameters.digitpresentationtime + parameters.maskpresentationtime

/ontrialend = [
	if (trial.practice_go.response == parameters.responsekey) 
		values.RT = trial.practice_go.latency 
	else {
		values.RT = ""; 
		values.latencytype = 0;
	};
	
	if (values.RT != "" && values.RT < parameters.anticipatoryresponsetime) {
		values.latencytype = 1;
	};

	if (values.RT != "" && values.RT >= parameters.anticipatoryresponsetime && values.RT < parameters.validresponsetime) {
		values.latencytype = 2;
	};
	
	if (values.RT != "" && values.RT >= parameters.validresponsetime) {
		values.latencytype = 3;
	};
	
	if (values.RT == "") {
		values.responsetype = "Omission"; 
	};

	if (values.RT != "" && values.RT < parameters.anticipatoryresponsetime) {
		values.responsetype = "Go Anticipatory"; 
	};
	
	if (values.RT >= parameters.anticipatoryresponsetime && values.RT < parameters.validresponsetime) 
		values.responsetype = "Go Ambiguous";
		
	if (values.RT >= parameters.validresponsetime) {
		values.responsetype = "Go Success"; 
	};
]
/recorddata = true
/branch = [if (trial.practice_go.error) trial.feedback]
</trial>


<trial practice_nogo>
/pretrialpause = parameters.ITI
/ontrialbegin = [
	values.trialtype = "NoGo";
	values.digit = list.practice_digitsequence.nextvalue;
	values.fontsize = list.practice_fontsizes.nextvalue;
	trial.practice_nogo.insertstimulustime(picture.mask, parameters.digitpresentationtime);
	trial.practice_nogo.insertstimulustime(shape.background, (parameters.digitpresentationtime + parameters.maskpresentationtime));
]
/ontrialend = [
	trial.practice_nogo.resetstimulusframes();
]
/stimulustimes = [0 = background, digit]
/beginresponsetime = 0
/responseinterrupt = frames
/validresponse = (parameters.responsekey, 0)
/monkeyresponse = (parameters.responsekey, 0)
/correctresponse = (0)
/trialduration = parameters.digitpresentationtime + parameters.maskpresentationtime

/ontrialend = [

	if (trial.practice_nogo.response == parameters.responsekey) 
		values.RT = trial.practice_nogo.latency 
	else {
		values.RT = ""; 
		values.latencytype = 0;
	};
	
	if (values.RT != "" && values.RT < parameters.anticipatoryresponsetime) {
		values.latencytype = 1;
	};
	
	if (values.RT != "" && values.RT >= parameters.anticipatoryresponsetime && values.RT < parameters.validresponsetime) {
		values.latencytype = 2;
	};
	
	if (values.RT != "" && values.RT >= parameters.validresponsetime) {
		values.latencytype = 3;
	};
	
	if (values.RT == "") {
		values.responsetype = "NoGo Success"; 
	} else {
		values.responsetype = "NoGo Failure";
	};
]

/recorddata = true
/branch = [if (trial.practice_nogo.error) trial.feedback]
</trial>


Note: presents an error feedback stimulus for 500ms
<trial feedback>
/recorddata = false
/stimulusframes = [1 = background, errorfeedback]
/timeout = 500
</trial>

*****************************
General Helper Trial
*****************************

This trial is used when participants are asked to place their fingers on specific response
buttons. On the touchscreen, this trial presents the (inactive) response buttons to the participants.
<trial getReady>
/ stimulusframes = [1 = getReady]
/ trialduration = 5000
/ validresponse = (parameters.responsekey)
/ beginresponsetime = 5000
/ errormessage = false
/ recorddata = false
</trial>

*******************************************************************************************************************
*******************************************************************************************************************
	TRIALS
*******************************************************************************************************************
*******************************************************************************************************************

Note: 
* presents digit for parameters.digitpresentationtime followed by a mask for parameters.maskpresentationtime
* latency is measured from onset of digit 
* summary variables are updated
* latencies are tracked to be able to calculate the mean latencies of the last 4 consecutive non-digit3 trials 
that elicited a correct response before a digit3 trial
* latencies of Go-success trials are stored in list.validgolatencies to calculate Std


presents the go-trials (digits !=3))
<trial go>
/pretrialpause = parameters.ITI
/ontrialbegin = [
	values.trialtype =  "Go";
	values.digit = list.digitsequence.nextvalue;
	values.count_Go += 1;
	values.fontsize = list.fontsizes.nextvalue;
	trial.go.insertstimulustime(picture.mask, parameters.digitpresentationtime);
	trial.go.insertstimulustime(shape.background, (parameters.digitpresentationtime + parameters.maskpresentationtime));
	values.probetrial = list.mindwanderingprobes.nextvalue;
]
/ ontrialend = [
		trial.go.resetstimulusframes();
]
/stimulustimes = [0 = background, digit]
/beginresponsetime = 0
/responseinterrupt = frames
/validresponse = (parameters.responsekey, 0)
/monkeyresponse = (parameters.responsekey, 0)
/correctresponse = (parameters.responsekey)
/trialduration = parameters.digitpresentationtime + parameters.maskpresentationtime

/ontrialend = [
	if (trial.go.response == parameters.responsekey) 
		values.RT = trial.go.latency 
	else {
		values.RT = ""; 
		values.latencytype = 0;
	};
	
	if (values.RT != "" && values.RT < parameters.anticipatoryresponsetime) {
		values.latencytype = 1;
	};

	if (values.RT != "" && values.RT >= parameters.anticipatoryresponsetime && values.RT < parameters.validresponsetime) {
		values.latencytype = 2;
	};
	
	if (values.RT != "" && values.RT >= parameters.validresponsetime) {
		values.latencytype = 3;
	};
	
	if (values.RT == "") {
		values.responsetype = "Omission"; 
		values.incorrectsuppressions += 1;
	};

	if (values.RT != "" && values.RT < parameters.anticipatoryresponsetime) {
		values.responsetype = "Go Anticipatory"; 
		values.count_anticipatory += 1;
	};
	
	if (values.RT >= parameters.anticipatoryresponsetime && values.RT < parameters.validresponsetime) 
		values.responsetype = "Go Ambiguous";
		
	if (values.RT >= parameters.validresponsetime) {
		values.responsetype = "Go Success"; 
		values.count_validgo += 1; 
		list.validgolatencies.insertitem(values.RT, 1);
	};

	if (values.RT !="" && trial.go.correct) {
		values.RT1 = values.RT2; 
		values.RT2 = values.RT3; 
		values.RT3 = values.RT4; 
		values.RT4 = values.RT;
	} else {
		values.RT1 = 0; 
		values.RT2 = 0; 
		values.RT3 = 0; 
		values.RT4 = 0; 
		values.fourfilled = 0;
	};

	if (trial.go.correct && values.RT1 != 0 && values.RT2 != 0 && values.RT3 != 0 && values.RT4 != 0 ) {
		values.fourfilled = 1;
	};
]
/recorddata = true
/branch = [if (parameters.run_mindwanderingprobe == 1 && values.probetrial == 1) 
				surveypage.probe]
</trial>


presents the nogo trials (digit == 3)
<trial nogo>
/pretrialpause = parameters.ITI
/ontrialbegin = [
	values.trialtype = "NoGo";
	values.count_NoGo += 1;
	values.digit = list.digitsequence.nextvalue;
	values.fontsize = list.fontsizes.nextvalue;
	values.probetrial = list.mindwanderingprobes.nextvalue;

	trial.nogo.insertstimulustime(picture.mask, parameters.digitpresentationtime);
	trial.nogo.insertstimulustime(shape.background, (parameters.digitpresentationtime + parameters.maskpresentationtime));
]
/ontrialend = [
	trial.nogo.resetstimulusframes();
]

/stimulustimes = [0 = background, digit]
/responsetime = 0
/responseinterrupt = frames
/validresponse = (parameters.responsekey, 0)
/monkeyresponse = (parameters.responsekey, 0)
/correctresponse = (0)
/trialduration = parameters.digitpresentationtime + parameters.maskpresentationtime

/ontrialend = [

	if (trial.nogo.response == parameters.responsekey) 
		values.RT = trial.nogo.latency 
	else {
		values.RT = ""; 
		values.latencytype = 0;
	};
	
	if (values.RT != "" && values.RT < parameters.anticipatoryresponsetime) {
		values.latencytype = 1;
	};
	
	if (values.RT != "" && values.RT >= parameters.anticipatoryresponsetime && values.RT < parameters.validresponsetime) {
		values.latencytype = 2;
	};
	
	if (values.RT != "" && values.RT >= parameters.validresponsetime) {
		values.latencytype = 3;
	};
	
	if (values.RT == "") {
		values.responsetype = "NoGo Success"; 
		values.correctsuppressions += 1;
	} else {
		values.responsetype = "NoGo Failure";
	};

	if (values.RT == "" && values.fourfilled == 1) {
		values.count_4rts_successsuppression += 1;
		values.sumrt_successsuppression += (values.RT1 + values.RT2 + values.RT3 + values.RT4);
	};

	if (values.RT != "" && values.fourfilled == 1) {
		values.count_4rts_failedsuppression += 1;
		values.sumrt_failedsuppression += (values.RT1 + values.RT2 + values.RT3 + values.RT4);
	};

	values.RT1 = 0; 
	values.RT2 = 0; 
	values.RT3 = 0; 
	values.RT4 = 0; 
	values.fourfilled = 0;
]

/recorddata = true
/branch = [
	if (parameters.run_mindwanderingprobe == 1 && values.probetrial == 1) 
			surveypage.probe;
]
</trial>

*******************************************************************************************************************
*******************************************************************************************************************
	BLOCKS
*******************************************************************************************************************
*******************************************************************************************************************

<block practice>
/trials = [1 = getReady; 2-19 = list.practice_trialtype]
/onblockend = [list.fontsizes.reset()]
</block>

<block SART>
/trials = [1 = getReady; 2-226 = list.trialtype]
</block>

*******************************************************************************************************************
*******************************************************************************************************************
	EXPERIMENT
*******************************************************************************************************************
*******************************************************************************************************************
<expt>
/preinstructions = (practiceend)
/blocks = [1 = SART]
/onexptend = [values.completed = 1]
</expt>


<monkey>
/ latencydistribution = normal(300, 250)
</monkey>
**************************************************************************************************************
												End of File
**************************************************************************************************************2,9,3,9,7,5,9,9,5,3,1,9,6,7,6,1,2,8,7,3,1,9,1,2,8,
